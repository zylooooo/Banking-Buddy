name: Deploy User Service

on:
  push:
    branches: [main, integration]
    paths:
      - 'services/user-service/**'
      - '.github/workflows/deploy-user-service.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: ap-southeast-1
  SERVICE_PATH: services/user-service

# ‚úÖ BEST PRACTICE #1: Concurrency control
concurrency:
  group: deploy-user-service-${{ github.event.inputs.environment || 'dev' }}
  cancel-in-progress: false

jobs:
  # Job 1: Build (Runs automatically on push OR manual trigger)
  build:
    name: Build Application
    runs-on: ubuntu-latest
    # ‚úÖ BEST PRACTICE #2: Minimal permissions
    permissions:
      contents: read
      actions: write  # To upload artifacts
    # ‚úÖ BEST PRACTICE #3: Timeout protection
    timeout-minutes: 10
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'corretto'
          cache: 'maven'
      
      - name: Build with Maven
        run: |
          cd ${{ env.SERVICE_PATH }}
          mvn clean package -DskipTests
      
      - name: Verify JAR exists
        run: |
          if [ ! -f "${{ env.SERVICE_PATH }}/target/user-service-0.0.1-SNAPSHOT.jar" ]; then
            echo "Error: JAR file not found!"
            exit 1
          fi
          ls -lh ${{ env.SERVICE_PATH }}/target/*.jar
          echo "Build completed successfully! ‚úÖ"
      
      - name: Upload JAR artifact
        uses: actions/upload-artifact@v4
        with:
          name: user-service-jar
          path: ${{ env.SERVICE_PATH }}/target/user-service-0.0.1-SNAPSHOT.jar
          retention-days: 7
      
      # ‚úÖ BEST PRACTICE #4: Export artifact info for downstream job
      - name: Set artifact metadata
        id: metadata
        run: |
          echo "build_time=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT
          echo "build_sha=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "build_ref=${{ github.ref }}" >> $GITHUB_OUTPUT
          echo "build_actor=${{ github.actor }}" >> $GITHUB_OUTPUT

  # Job 2: Deploy (Manual trigger only)
  deploy:
    name: Deploy to Elastic Beanstalk
    needs: build
    runs-on: ubuntu-latest
    # ‚úÖ BEST PRACTICE #5: Least privilege permissions
    permissions:
      id-token: write   # Required for OIDC
      contents: read    # Minimal read access
    
    # ‚úÖ BEST PRACTICE #6: Timeout protection
    timeout-minutes: 30
    
    # Only deploy on manual workflow_dispatch trigger (not on push)
    if: github.event_name == 'workflow_dispatch' && needs.build.result == 'success'
    environment: 
      name: ${{ github.event.inputs.environment || 'dev' }}
      # Environment protection handled in GitHub settings
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      # ‚úÖ BEST PRACTICE #8: OIDC for AWS (no static credentials)
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-${{ github.run_id }}
      
      # ‚úÖ BEST PRACTICE #9: Pre-flight checks
      - name: Verify Elastic Beanstalk environment exists
        run: |
          echo "Checking if Elastic Beanstalk environment exists..."
          ENV_STATUS=$(aws elasticbeanstalk describe-environments \
            --environment-names banking-buddy-${{ github.event.inputs.environment || 'dev' }}-user-env \
            --region ${{ env.AWS_REGION }} \
            --query 'Environments[0].Status' \
            --output text 2>/dev/null || echo "NotFound")
          
          if [ "$ENV_STATUS" = "NotFound" ] || [ -z "$ENV_STATUS" ] || [ "$ENV_STATUS" = "None" ]; then
            echo "‚ùå Infrastructure does not exist."
            echo "Please provision infrastructure first with: cd infrastructure/terraform && terraform apply"
            exit 1
          elif echo "$ENV_STATUS" | grep -q "Ready\|Updating"; then
            echo "‚úÖ Infrastructure exists and is ready: $ENV_STATUS"
          else
            echo "‚ö†Ô∏è Infrastructure exists but status is: $ENV_STATUS"
            echo "Proceeding with deployment..."
          fi
      
      - name: Download JAR artifact
        uses: actions/download-artifact@v4
        with:
          name: user-service-jar
          path: ${{ env.SERVICE_PATH }}/target/
      
      - name: Verify artifact downloaded
        run: |
          if [ ! -f "${{ env.SERVICE_PATH }}/target/user-service-0.0.1-SNAPSHOT.jar" ]; then
            echo "Error: JAR file not found in artifacts!"
            exit 1
          fi
          ls -lh ${{ env.SERVICE_PATH }}/target/*.jar
          echo "üì¶ Artifact verified successfully"
      
      # ‚úÖ BEST PRACTICE #10: Deploy with version tracking
      - name: Deploy to Elastic Beanstalk
        uses: ./.github/actions/deploy-to-eb
        with:
          # No AWS credentials - OIDC handles this
          aws-access-key-id: ""
          aws-secret-access-key: ""
          aws-region: ${{ env.AWS_REGION }}
          application-name: banking-buddy-${{ github.event.inputs.environment || 'dev' }}-user-service
          environment-name: banking-buddy-${{ github.event.inputs.environment || 'dev' }}-user-env
          deployment-package: ${{ env.SERVICE_PATH }}/target/user-service-0.0.1-SNAPSHOT.jar
        env:
          AWS_ACCESS_KEY_ID: ""  # Empty because we're using OIDC
          AWS_SECRET_ACCESS_KEY: ""
      
      # ‚úÖ BEST PRACTICE #11: Post-deployment verification
      - name: Verify deployment health
        id: health-check
        run: |
          echo "Verifying deployment health..."
          ENV_URL=$(aws elasticbeanstalk describe-environments \
            --environment-names banking-buddy-${{ github.event.inputs.environment || 'dev' }}-user-env \
            --region ${{ env.AWS_REGION }} \
            --query 'Environments[0].CNAME' \
            --output text)
          
          echo "Environment URL: http://${ENV_URL}"
          echo "environment_url=http://${ENV_URL}" >> $GITHUB_OUTPUT
          
          # Wait for service to be healthy (max 5 minutes)
          MAX_ATTEMPTS=30
          ATTEMPT=0
          HEALTH_STATUS="unknown"
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://${ENV_URL}/actuator/health" || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              HEALTH_STATUS="healthy"
              echo "‚úÖ Deployment verified! Service is healthy (HTTP $HTTP_CODE)"
              echo "health_status=healthy" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
            echo "‚è≥ Attempt $ATTEMPT/$MAX_ATTEMPTS: Waiting for service to be healthy (HTTP $HTTP_CODE)..."
            sleep 10
          done
          
          echo "‚ùå Deployment verification failed after $MAX_ATTEMPTS attempts"
          echo "health_status=unhealthy" >> $GITHUB_OUTPUT
          echo "Service may still be starting up or may have issues"
          echo "Check the Elastic Beanstalk environment for details"
          exit 1
      
      # ‚úÖ BEST PRACTICE #12: Deployment summary
      - name: Deployment summary
        if: always()
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ github.event.inputs.environment || 'dev' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Service | User Service |" >> $GITHUB_STEP_SUMMARY
          echo "| Build SHA | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deployed By | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Status | ${{ steps.health-check.outputs.health_status || 'unknown' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Environment URL | ${{ steps.health-check.outputs.environment_url || 'N/A' }} |" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.health-check.outputs.health_status }}" = "healthy" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ Deployment completed successfully!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Health Check" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
            echo "curl ${{ steps.health-check.outputs.environment_url }}/actuator/health" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ùå Deployment may have issues. Check logs for details." >> $GITHUB_STEP_SUMMARY
          fi
      
      - name: Display deployment info
        if: always()
        run: |
          echo "üöÄ Deployment Summary"
          echo "==================="
          echo "Environment: ${{ github.event.inputs.environment || 'dev' }}"
          echo "Status: ${{ steps.health-check.outputs.health_status || 'unknown' }}"
          echo "URL: ${{ steps.health-check.outputs.environment_url || 'N/A' }}"
          echo ""
          if [ "${{ steps.health-check.outputs.health_status }}" = "healthy" ]; then
            echo "‚úÖ Deployment successful!"
          else
            echo "‚ö†Ô∏è Deployment completed but health check failed"
          fi