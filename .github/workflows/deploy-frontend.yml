name: Deploy Frontend

on:
  push:
    branches: [main, integration]
    paths:
      - 'services/frontend/**'
      - '.github/workflows/deploy-frontend.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: ap-southeast-1
  SERVICE_PATH: services/frontend

permissions:
  contents: read    # Required to checkout code

jobs:
  # Job 1: Build (Runs automatically on push)
  build:
    name: Build Application
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: ${{ env.SERVICE_PATH }}/package-lock.json
      
      - name: Install dependencies
        run: |
          cd ${{ env.SERVICE_PATH }}
          npm ci
      
      - name: Run linter
        run: |
          cd ${{ env.SERVICE_PATH }}
          npm run lint
      
      - name: Build production bundle
        env:
          # Environment variables from Terraform outputs (or GitHub secrets)
          VITE_API_BASE_URL: ${{ secrets.VITE_API_BASE_URL }}
          VITE_COGNITO_USER_POOL_ID: ${{ secrets.VITE_COGNITO_USER_POOL_ID }}
          VITE_COGNITO_CLIENT_ID: ${{ secrets.VITE_COGNITO_CLIENT_ID }}
          VITE_COGNITO_DOMAIN: ${{ secrets.VITE_COGNITO_DOMAIN }}
          VITE_AWS_REGION: ${{ env.AWS_REGION }}
          VITE_REDIRECT_URI: ${{ secrets.VITE_REDIRECT_URI }}
          VITE_LOGOUT_URI: ${{ secrets.VITE_LOGOUT_URI }}
        run: |
          cd ${{ env.SERVICE_PATH }}
          npm run build
      
      - name: Verify build artifacts
        run: |
          if [ ! -f "${{ env.SERVICE_PATH }}/dist/index.html" ]; then
            echo "Error: Build artifacts not found!"
            exit 1
          fi
          ls -lh ${{ env.SERVICE_PATH }}/dist/
          echo "Build completed successfully! ‚úÖ"
      
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: ${{ env.SERVICE_PATH }}/dist/
          retention-days: 7

  # Job 2: Deploy to S3 and CloudFront (Automated for dev, manual approval for staging/prod)
  deploy:
    name: Deploy to S3 and CloudFront
    needs: build
    runs-on: ubuntu-latest
    # Uses GitHub Environments for manual approval on staging/prod
    # Dev deployments are fully automated (no environment protection)
    environment: 
      name: ${{ github.event.inputs.environment || 'dev' }}
    
    env:
      DEPLOY_ENV: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Verify S3 bucket exists
        run: |
          echo "Checking if frontend S3 bucket exists..."
          
          # Query AWS for S3 buckets matching our naming pattern
          # Pattern: banking-buddy-{env}-frontend-*
          NAME_PREFIX="banking-buddy-${{ github.event.inputs.environment || 'dev' }}-frontend"
          
          S3_BUCKET=$(aws s3api list-buckets \
            --query "Buckets[?starts_with(Name, '${NAME_PREFIX}')].Name" \
            --output text 2>/dev/null | head -n1)
          
          if [ -z "$S3_BUCKET" ] || [ "$S3_BUCKET" = "None" ]; then
            echo "‚ùå Frontend S3 bucket not found."
            echo "Looking for buckets with prefix: ${NAME_PREFIX}"
            echo ""
            echo "Please ensure infrastructure is provisioned first:"
            echo "  cd infrastructure/terraform && terraform apply"
            exit 1
          fi
          
          echo "‚úÖ S3 bucket found: $S3_BUCKET"
          echo "S3_BUCKET=$S3_BUCKET" >> $GITHUB_ENV
      
      - name: Verify CloudFront distribution exists
        env:
          S3_BUCKET: ${{ env.S3_BUCKET }}
        run: |
          echo "Checking if CloudFront distribution exists..."
          
          if [ -z "$S3_BUCKET" ]; then
            echo "‚ùå S3_BUCKET environment variable not set"
            exit 1
          fi
          
          # Get all CloudFront distributions and find the one with matching S3 bucket origin
          # We'll list all distributions and check their origins
          DIST_ID=""
          
          # Try to find by matching S3 bucket name in origin domain
          DIST_LIST=$(aws cloudfront list-distributions \
            --query 'DistributionList.Items[*].[Id, Comment, Origins.Items[0].DomainName]' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$DIST_LIST" ]; then
            # Find distribution where origin domain contains our S3 bucket name
            DIST_ID=$(echo "$DIST_LIST" | grep -i "$S3_BUCKET" | head -n1 | awk '{print $1}')
          fi
          
          # If still not found, try finding by comment (CloudFront comments often include name prefix)
          if [ -z "$DIST_ID" ] || [ "$DIST_ID" = "None" ]; then
            NAME_PREFIX="banking-buddy-${{ github.event.inputs.environment || 'dev' }}"
            DIST_ID=$(echo "$DIST_LIST" | grep -i "frontend\|${NAME_PREFIX}" | head -n1 | awk '{print $1}')
          fi
          
          if [ -z "$DIST_ID" ] || [ "$DIST_ID" = "None" ]; then
            echo "‚ùå CloudFront distribution not found for S3 bucket: $S3_BUCKET"
            echo ""
            echo "Available distributions:"
            echo "$DIST_LIST" | head -5 || echo "  (Could not list distributions)"
            echo ""
            echo "Please ensure infrastructure is provisioned first:"
            echo "  cd infrastructure/terraform && terraform apply"
            exit 1
          fi
          
          echo "‚úÖ CloudFront distribution found: $DIST_ID"
          echo "DIST_ID=$DIST_ID" >> $GITHUB_ENV
      
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-build
          path: ${{ env.SERVICE_PATH }}/dist/
      
      - name: Verify artifacts downloaded
        run: |
          if [ ! -f "${{ env.SERVICE_PATH }}/dist/index.html" ]; then
            echo "Error: Build artifacts not found!"
            exit 1
          fi
          echo "‚úÖ Build artifacts verified"
          ls -lh ${{ env.SERVICE_PATH }}/dist/
      
      - name: Upload to S3
        env:
          S3_BUCKET: ${{ env.S3_BUCKET }}
        run: |
          if [ -z "$S3_BUCKET" ]; then
            echo "‚ùå S3_BUCKET environment variable is not set."
            echo "Please ensure infrastructure verification step completed successfully."
            exit 1
          fi
          
          echo "Uploading files to S3 bucket: $S3_BUCKET"
          
          # Upload all files except index.html (with cache control for static assets)
          aws s3 sync ${{ env.SERVICE_PATH }}/dist/ s3://$S3_BUCKET/ \
            --delete \
            --cache-control "public, max-age=31536000, immutable" \
            --exclude "index.html" \
            --exclude "*.html"
          
          # Upload index.html with no cache (important for SPA routing)
          aws s3 cp ${{ env.SERVICE_PATH }}/dist/index.html s3://$S3_BUCKET/index.html \
            --content-type "text/html" \
            --cache-control "no-cache, no-store, must-revalidate"
          
          echo "‚úÖ Files uploaded to S3"
      
      - name: Invalidate CloudFront cache
        env:
          DIST_ID: ${{ env.DIST_ID }}
        run: |
          if [ -z "$DIST_ID" ]; then
            echo "‚ùå DIST_ID environment variable is not set."
            echo "Please ensure infrastructure verification step completed successfully."
            exit 1
          fi
          
          echo "Invalidating CloudFront cache for distribution: $DIST_ID"
          
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id $DIST_ID \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)
          
          echo "‚úÖ CloudFront cache invalidation created: $INVALIDATION_ID"
          echo "‚è≥ Waiting for invalidation to complete (this may take a few minutes)..."
          
          aws cloudfront wait invalidation-completed \
            --distribution-id $DIST_ID \
            --id $INVALIDATION_ID
          
          echo "‚úÖ Cache invalidation completed!"
      
      - name: Update Cognito callback URLs
        env:
          DIST_ID: ${{ env.DIST_ID }}
        run: |
          if [ -z "$DIST_ID" ]; then
            echo "‚ö†Ô∏è CloudFront distribution ID not available, skipping Cognito update"
            exit 0
          fi
          
          echo "Updating Cognito User Pool Client callback URLs..."
          
          # Get CloudFront distribution domain name
          FRONTEND_DOMAIN=$(aws cloudfront get-distribution \
            --id $DIST_ID \
            --query 'Distribution.DomainName' \
            --output text 2>/dev/null || echo "")
          
          if [ -z "$FRONTEND_DOMAIN" ]; then
            echo "‚ö†Ô∏è Could not retrieve CloudFront domain name"
            exit 0
          fi
          
          FRONTEND_URL="https://${FRONTEND_DOMAIN}"
          CALLBACK_URL="${FRONTEND_URL}/callback"
          LOGOUT_URL="${FRONTEND_URL}"
          
          echo "Frontend URL: $FRONTEND_URL"
          echo "Callback URL: $CALLBACK_URL"
          echo "Logout URL: $LOGOUT_URL"
          
          # Get Cognito User Pool ID and Client ID from environment variables or secrets
          # These should be set in GitHub secrets
          COGNITO_USER_POOL_ID="${{ secrets.VITE_COGNITO_USER_POOL_ID }}"
          COGNITO_CLIENT_ID="${{ secrets.VITE_COGNITO_CLIENT_ID }}"
          
          if [ -z "$COGNITO_USER_POOL_ID" ] || [ -z "$COGNITO_CLIENT_ID" ]; then
            echo "‚ö†Ô∏è Cognito credentials not available in secrets, skipping callback URL update"
            echo "Please manually update Cognito User Pool Client callback URLs to include:"
            echo "  Callback: $CALLBACK_URL"
            echo "  Logout: $LOGOUT_URL"
            exit 0
          fi
          
          # Get current callback URLs
          CURRENT_CALLBACKS=$(aws cognito-idp describe-user-pool-client \
            --user-pool-id "$COGNITO_USER_POOL_ID" \
            --client-id "$COGNITO_CLIENT_ID" \
            --query 'UserPoolClient.CallbackURLs' \
            --output json 2>/dev/null || echo "[]")
          
          CURRENT_LOGOUTS=$(aws cognito-idp describe-user-pool-client \
            --user-pool-id "$COGNITO_USER_POOL_ID" \
            --client-id "$COGNITO_CLIENT_ID" \
            --query 'UserPoolClient.LogoutURLs' \
            --output json 2>/dev/null || echo "[]")
          
          # Check if our URLs are already in the lists
          CALLBACK_EXISTS=$(echo "$CURRENT_CALLBACKS" | grep -o "$CALLBACK_URL" || echo "")
          LOGOUT_EXISTS=$(echo "$CURRENT_LOGOUTS" | grep -o "$LOGOUT_URL" || echo "")
          
          if [ -n "$CALLBACK_EXISTS" ] && [ -n "$LOGOUT_EXISTS" ]; then
            echo "‚úÖ Callback URLs already configured correctly"
            exit 0
          fi
          
          # Build new callback URLs list (keep existing + add new if not present)
          NEW_CALLBACKS=$(echo "$CURRENT_CALLBACKS" | jq -c ". + [\"$CALLBACK_URL\", \"http://localhost:3000/callback\"] | unique" 2>/dev/null || echo "[\"$CALLBACK_URL\", \"http://localhost:3000/callback\"]")
          NEW_LOGOUTS=$(echo "$CURRENT_LOGOUTS" | jq -c ". + [\"$LOGOUT_URL\", \"http://localhost:3000\"] | unique" 2>/dev/null || echo "[\"$LOGOUT_URL\", \"http://localhost:3000\"]")
          
          # Update Cognito User Pool Client
          echo "Updating Cognito User Pool Client callback URLs..."
          echo "New callback URLs: $NEW_CALLBACKS"
          echo "New logout URLs: $NEW_LOGOUTS"
          
          UPDATE_RESULT=$(aws cognito-idp update-user-pool-client \
            --user-pool-id "$COGNITO_USER_POOL_ID" \
            --client-id "$COGNITO_CLIENT_ID" \
            --callback-urls "$NEW_CALLBACKS" \
            --logout-urls "$NEW_LOGOUTS" \
            --output json 2>&1)
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Cognito callback URLs updated successfully"
            
            # Verify the update by checking current callback URLs
            VERIFIED_CALLBACKS=$(aws cognito-idp describe-user-pool-client \
              --user-pool-id "$COGNITO_USER_POOL_ID" \
              --client-id "$COGNITO_CLIENT_ID" \
              --query 'UserPoolClient.CallbackURLs' \
              --output json 2>/dev/null || echo "[]")
            
            VERIFIED_LOGOUTS=$(aws cognito-idp describe-user-pool-client \
              --user-pool-id "$COGNITO_USER_POOL_ID" \
              --client-id "$COGNITO_CLIENT_ID" \
              --query 'UserPoolClient.LogoutURLs' \
              --output json 2>/dev/null || echo "[]")
            
            echo "Verified callback URLs: $VERIFIED_CALLBACKS"
            echo "Verified logout URLs: $VERIFIED_LOGOUTS"
            
            # Check if our URLs are in the verified list
            if echo "$VERIFIED_CALLBACKS" | grep -q "$CALLBACK_URL"; then
              echo "‚úÖ CloudFront callback URL confirmed in Cognito"
            else
              echo "‚ö†Ô∏è Warning: CloudFront callback URL may not be in Cognito"
            fi
          else
            echo "‚ùå Failed to update Cognito callback URLs"
            echo "Error output: $UPDATE_RESULT"
            echo ""
            echo "Please manually update in AWS Console:"
            echo "  Cognito User Pool: $COGNITO_USER_POOL_ID"
            echo "  Client ID: $COGNITO_CLIENT_ID"
            echo "  Add Callback URL: $CALLBACK_URL"
            echo "  Add Logout URL: $LOGOUT_URL"
            exit 1
          fi
      
      - name: Get frontend URL
        env:
          DIST_ID: ${{ env.DIST_ID }}
        run: |
          if [ -z "$DIST_ID" ]; then
            echo "‚ö†Ô∏è CloudFront distribution ID not available"
            exit 0
          fi
          
          # Get CloudFront distribution domain name
          FRONTEND_DOMAIN=$(aws cloudfront get-distribution \
            --id $DIST_ID \
            --query 'Distribution.DomainName' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$FRONTEND_DOMAIN" ]; then
            FRONTEND_URL="https://${FRONTEND_DOMAIN}"
            echo "üöÄ Deployment completed successfully!"
            echo "üìç Frontend URL: $FRONTEND_URL"
            echo ""
            echo "Test the deployment:"
            echo "curl -I $FRONTEND_URL"
          else
            echo "üöÄ Deployment completed successfully!"
            echo "‚ö†Ô∏è Could not retrieve CloudFront domain name"
          fi

