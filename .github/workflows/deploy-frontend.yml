name: Deploy Frontend

on:
  push:
    branches: [master, integration]
    paths:
      - 'services/frontend/**'
      - '.github/workflows/deploy-frontend.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: ap-southeast-1
  SERVICE_PATH: services/frontend

permissions:
  contents: read    # Required to checkout code

jobs:
  # Job 1: Build (Runs automatically on push)
  build:
    name: Build Application
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: ${{ env.SERVICE_PATH }}/package-lock.json
      
      - name: Install dependencies
        run: |
          cd ${{ env.SERVICE_PATH }}
          npm ci
      
      - name: Run linter
        run: |
          cd ${{ env.SERVICE_PATH }}
          npm run lint
      
      - name: Build production bundle
        env:
          # Environment variables from Terraform outputs (or GitHub secrets)
          VITE_API_BASE_URL: ${{ secrets.VITE_API_BASE_URL }}
          VITE_AUDIT_API_BASE_URL: ${{ secrets.VITE_AUDIT_API_BASE_URL }}
          VITE_COGNITO_USER_POOL_ID: ${{ secrets.VITE_COGNITO_USER_POOL_ID }}
          VITE_COGNITO_CLIENT_ID: ${{ secrets.VITE_COGNITO_CLIENT_ID }}
          VITE_COGNITO_DOMAIN: ${{ secrets.VITE_COGNITO_DOMAIN }}
          VITE_AWS_REGION: ${{ env.AWS_REGION }}
          VITE_REDIRECT_URI: ${{ secrets.VITE_REDIRECT_URI }}
          VITE_LOGOUT_URI: ${{ secrets.VITE_LOGOUT_URI }}
        run: |
          cd ${{ env.SERVICE_PATH }}
          npm run build
      
      - name: Verify build artifacts
        run: |
          if [ ! -f "${{ env.SERVICE_PATH }}/dist/index.html" ]; then
            echo "Error: Build artifacts not found!"
            exit 1
          fi
          ls -lh ${{ env.SERVICE_PATH }}/dist/
          echo "Build completed successfully! ‚úÖ"
      
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: ${{ env.SERVICE_PATH }}/dist/
          retention-days: 7

  # Job 2: Deploy to S3 and CloudFront (Automated for dev, manual approval for staging/prod)
  deploy:
    name: Deploy to S3 and CloudFront
    needs: build
    runs-on: ubuntu-latest
    # Uses GitHub Environments for manual approval on staging/prod
    # Dev deployments are fully automated (no environment protection)
    environment: 
      name: ${{ github.event.inputs.environment || 'dev' }}
    
    env:
      DEPLOY_ENV: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Verify S3 bucket exists
        run: |
          echo "Checking if frontend S3 bucket exists..."
          
          # Query AWS for S3 buckets matching our naming pattern
          # Pattern: banking-buddy-{env}-frontend-*
          NAME_PREFIX="banking-buddy-${{ github.event.inputs.environment || 'dev' }}-frontend"
          
          S3_BUCKET=$(aws s3api list-buckets \
            --query "Buckets[?starts_with(Name, '${NAME_PREFIX}')].Name" \
            --output text 2>/dev/null | head -n1)
          
          if [ -z "$S3_BUCKET" ] || [ "$S3_BUCKET" = "None" ]; then
            echo "‚ùå Frontend S3 bucket not found."
            echo "Looking for buckets with prefix: ${NAME_PREFIX}"
            echo ""
            echo "Please ensure infrastructure is provisioned first:"
            echo "  cd infrastructure/terraform && terraform apply"
            exit 1
          fi
          
          echo "‚úÖ S3 bucket found: $S3_BUCKET"
          echo "S3_BUCKET=$S3_BUCKET" >> $GITHUB_ENV
      
      - name: Verify CloudFront distribution exists
        env:
          S3_BUCKET: ${{ env.S3_BUCKET }}
        run: |
          echo "Checking if CloudFront distribution exists..."
          
          if [ -z "$S3_BUCKET" ]; then
            echo "‚ùå S3_BUCKET environment variable not set"
            exit 1
          fi
          
          # Get all CloudFront distributions and find the one with matching S3 bucket origin
          # We'll list all distributions and check their origins
          DIST_ID=""
          
          # Try to find by matching S3 bucket name in origin domain
          DIST_LIST=$(aws cloudfront list-distributions \
            --query 'DistributionList.Items[*].[Id, Comment, Origins.Items[0].DomainName]' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$DIST_LIST" ]; then
            # Find distribution where origin domain contains our S3 bucket name
            DIST_ID=$(echo "$DIST_LIST" | grep -i "$S3_BUCKET" | head -n1 | awk '{print $1}')
          fi
          
          # If still not found, try finding by comment (CloudFront comments often include name prefix)
          if [ -z "$DIST_ID" ] || [ "$DIST_ID" = "None" ]; then
            NAME_PREFIX="banking-buddy-${{ github.event.inputs.environment || 'dev' }}"
            DIST_ID=$(echo "$DIST_LIST" | grep -i "frontend\|${NAME_PREFIX}" | head -n1 | awk '{print $1}')
          fi
          
          if [ -z "$DIST_ID" ] || [ "$DIST_ID" = "None" ]; then
            echo "‚ùå CloudFront distribution not found for S3 bucket: $S3_BUCKET"
            echo ""
            echo "Available distributions:"
            echo "$DIST_LIST" | head -5 || echo "  (Could not list distributions)"
            echo ""
            echo "Please ensure infrastructure is provisioned first:"
            echo "  cd infrastructure/terraform && terraform apply"
            exit 1
          fi
          
          echo "‚úÖ CloudFront distribution found: $DIST_ID"
          echo "DIST_ID=$DIST_ID" >> $GITHUB_ENV
      
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-build
          path: ${{ env.SERVICE_PATH }}/dist/
      
      - name: Verify artifacts downloaded
        run: |
          if [ ! -f "${{ env.SERVICE_PATH }}/dist/index.html" ]; then
            echo "Error: Build artifacts not found!"
            exit 1
          fi
          echo "‚úÖ Build artifacts verified"
          ls -lh ${{ env.SERVICE_PATH }}/dist/
      
      - name: Upload to S3
        env:
          S3_BUCKET: ${{ env.S3_BUCKET }}
        run: |
          if [ -z "$S3_BUCKET" ]; then
            echo "‚ùå S3_BUCKET environment variable is not set."
            echo "Please ensure infrastructure verification step completed successfully."
            exit 1
          fi
          
          echo "Uploading files to S3 bucket: $S3_BUCKET"
          
          # Upload all files except index.html (with cache control for static assets)
          aws s3 sync ${{ env.SERVICE_PATH }}/dist/ s3://$S3_BUCKET/ \
            --delete \
            --cache-control "public, max-age=31536000, immutable" \
            --exclude "index.html" \
            --exclude "*.html"
          
          # Upload index.html with no cache (important for SPA routing)
          aws s3 cp ${{ env.SERVICE_PATH }}/dist/index.html s3://$S3_BUCKET/index.html \
            --content-type "text/html" \
            --cache-control "no-cache, no-store, must-revalidate"
          
          echo "‚úÖ Files uploaded to S3"
      
      - name: Invalidate CloudFront cache
        env:
          DIST_ID: ${{ env.DIST_ID }}
        run: |
          if [ -z "$DIST_ID" ]; then
            echo "‚ùå DIST_ID environment variable is not set."
            echo "Please ensure infrastructure verification step completed successfully."
            exit 1
          fi
          
          echo "Invalidating CloudFront cache for distribution: $DIST_ID"
          
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id $DIST_ID \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)
          
          echo "‚úÖ CloudFront cache invalidation created: $INVALIDATION_ID"
          echo "‚è≥ Waiting for invalidation to complete (this may take a few minutes)..."
          
          aws cloudfront wait invalidation-completed \
            --distribution-id $DIST_ID \
            --id $INVALIDATION_ID
          
          echo "‚úÖ Cache invalidation completed!"
      
      - name: Update Cognito callback URLs
        env:
          DIST_ID: ${{ env.DIST_ID }}
        run: |
          if [ -z "$DIST_ID" ]; then
            echo "‚ö†Ô∏è CloudFront distribution ID not available, skipping Cognito update"
            exit 0
          fi
          
          echo "Updating Cognito User Pool Client callback URLs..."
          
          # Get CloudFront distribution domain name
          FRONTEND_DOMAIN=$(aws cloudfront get-distribution \
            --id $DIST_ID \
            --query 'Distribution.DomainName' \
            --output text 2>/dev/null || echo "")
          
          if [ -z "$FRONTEND_DOMAIN" ]; then
            echo "‚ö†Ô∏è Could not retrieve CloudFront domain name"
            exit 0
          fi
          
          FRONTEND_URL="https://${FRONTEND_DOMAIN}"
          CALLBACK_URL="${FRONTEND_URL}/callback"
          LOGOUT_URL="${FRONTEND_URL}"
          
          echo "Frontend URL: $FRONTEND_URL"
          echo "Callback URL: $CALLBACK_URL"
          echo "Logout URL: $LOGOUT_URL"
          
          # Get Cognito User Pool ID and Client ID from environment variables or secrets
          # These should be set in GitHub secrets
          COGNITO_USER_POOL_ID="${{ secrets.VITE_COGNITO_USER_POOL_ID }}"
          COGNITO_CLIENT_ID="${{ secrets.VITE_COGNITO_CLIENT_ID }}"
          
          if [ -z "$COGNITO_USER_POOL_ID" ] || [ -z "$COGNITO_CLIENT_ID" ]; then
            echo "‚ö†Ô∏è Cognito credentials not available in secrets, skipping callback URL update"
            echo "Please manually update Cognito User Pool Client callback URLs to include:"
            echo "  Callback: $CALLBACK_URL"
            echo "  Logout: $LOGOUT_URL"
            exit 0
          fi
          
          # Get current app client configuration (CRITICAL: Must preserve all OAuth settings)
          CLIENT_CONFIG=$(aws cognito-idp describe-user-pool-client \
            --user-pool-id "$COGNITO_USER_POOL_ID" \
            --client-id "$COGNITO_CLIENT_ID" \
            --output json 2>/dev/null || echo "{}")
          
          CURRENT_CALLBACKS=$(echo "$CLIENT_CONFIG" | jq -r '.UserPoolClient.CallbackURLs // []' 2>/dev/null || echo "[]")
          CURRENT_LOGOUTS=$(echo "$CLIENT_CONFIG" | jq -r '.UserPoolClient.LogoutURLs // []' 2>/dev/null || echo "[]")
          
          # Get existing OAuth settings to preserve them (with sensible defaults if missing)
          # AWS CLI expects space-separated values, not JSON arrays
          EXISTING_OAUTH_FLOWS_JSON=$(echo "$CLIENT_CONFIG" | jq -c '.UserPoolClient.AllowedOAuthFlows // ["code", "implicit"]' 2>/dev/null || echo '["code", "implicit"]')
          EXISTING_OAUTH_SCOPES_JSON=$(echo "$CLIENT_CONFIG" | jq -c '.UserPoolClient.AllowedOAuthScopes // ["openid", "email", "phone", "profile", "aws.cognito.signin.user.admin"]' 2>/dev/null || echo '["openid", "email", "phone", "profile", "aws.cognito.signin.user.admin"]')
          EXISTING_IDENTITY_PROVIDERS_JSON=$(echo "$CLIENT_CONFIG" | jq -c '.UserPoolClient.SupportedIdentityProviders // ["COGNITO"]' 2>/dev/null || echo '["COGNITO"]')
          EXISTING_OAUTH_FLOWS_ENABLED=$(echo "$CLIENT_CONFIG" | jq -r '.UserPoolClient.AllowedOAuthFlowsUserPoolClient // true' 2>/dev/null || echo "true")
          
          # Convert JSON arrays to space-separated strings for AWS CLI
          EXISTING_OAUTH_FLOWS=$(echo "$EXISTING_OAUTH_FLOWS_JSON" | jq -r 'join(" ")' 2>/dev/null || echo "code implicit")
          EXISTING_OAUTH_SCOPES=$(echo "$EXISTING_OAUTH_SCOPES_JSON" | jq -r 'join(" ")' 2>/dev/null || echo "openid email phone profile aws.cognito.signin.user.admin")
          EXISTING_IDENTITY_PROVIDERS=$(echo "$EXISTING_IDENTITY_PROVIDERS_JSON" | jq -r 'join(" ")' 2>/dev/null || echo "COGNITO")
          
          # Validate that we have valid OAuth settings (not empty)
          if [ -z "$EXISTING_OAUTH_FLOWS" ] || [ -z "$EXISTING_OAUTH_SCOPES" ] || [ -z "$EXISTING_IDENTITY_PROVIDERS" ]; then
            echo "‚ö†Ô∏è Warning: Some OAuth settings are empty, using defaults"
            EXISTING_OAUTH_FLOWS=${EXISTING_OAUTH_FLOWS:-"code implicit"}
            EXISTING_OAUTH_SCOPES=${EXISTING_OAUTH_SCOPES:-"openid email phone profile aws.cognito.signin.user.admin"}
            EXISTING_IDENTITY_PROVIDERS=${EXISTING_IDENTITY_PROVIDERS:-"COGNITO"}
          fi
          
          # Check if our URLs are already in the lists
          CALLBACK_EXISTS=$(echo "$CURRENT_CALLBACKS" | grep -o "$CALLBACK_URL" || echo "")
          LOGOUT_EXISTS=$(echo "$CURRENT_LOGOUTS" | grep -o "$LOGOUT_URL" || echo "")
          
          if [ -n "$CALLBACK_EXISTS" ] && [ -n "$LOGOUT_EXISTS" ]; then
            echo "‚úÖ Callback URLs already configured correctly"
            echo "‚úÖ OAuth settings preserved"
            exit 0
          fi
          
          # Build new callback URLs list (keep existing + add new if not present)
          NEW_CALLBACKS=$(echo "$CURRENT_CALLBACKS" | jq -c ". + [\"$CALLBACK_URL\", \"http://localhost:3000/callback\"] | unique" 2>/dev/null || echo "[\"$CALLBACK_URL\", \"http://localhost:3000/callback\"]")
          NEW_LOGOUTS=$(echo "$CURRENT_LOGOUTS" | jq -c ". + [\"$LOGOUT_URL\", \"http://localhost:3000\"] | unique" 2>/dev/null || echo "[\"$LOGOUT_URL\", \"http://localhost:3000\"]")
          
          # Update Cognito User Pool Client
          # CRITICAL: Include ALL OAuth settings to prevent them from being reset
          echo "Updating Cognito User Pool Client callback URLs..."
          echo "New callback URLs: $NEW_CALLBACKS"
          echo "New logout URLs: $NEW_LOGOUTS"
          echo "Preserving OAuth flows (JSON): $EXISTING_OAUTH_FLOWS_JSON"
          echo "Preserving OAuth flows (space-separated): $EXISTING_OAUTH_FLOWS"
          echo "Preserving OAuth scopes (JSON): $EXISTING_OAUTH_SCOPES_JSON"
          echo "Preserving OAuth scopes (space-separated): $EXISTING_OAUTH_SCOPES"
          echo "Preserving identity providers (JSON): $EXISTING_IDENTITY_PROVIDERS_JSON"
          echo "Preserving identity providers (space-separated): $EXISTING_IDENTITY_PROVIDERS"
          echo "OAuth flows enabled: $EXISTING_OAUTH_FLOWS_ENABLED"
          
          # Build update command - AWS CLI expects space-separated values
          # Note: When values contain spaces, we need to handle them carefully in arrays
          UPDATE_ARGS=(
            --user-pool-id "$COGNITO_USER_POOL_ID"
            --client-id "$COGNITO_CLIENT_ID"
            --callback-urls "$NEW_CALLBACKS"
            --logout-urls "$NEW_LOGOUTS"
          )
          
          # Add OAuth settings - these are space-separated values
          # AWS CLI expects: --allowed-o-auth-flows code implicit
          # So we need to split the space-separated string and add each as a separate argument
          UPDATE_ARGS+=(--allowed-o-auth-flows)
          for flow in $EXISTING_OAUTH_FLOWS; do
            UPDATE_ARGS+=("$flow")
          done
          
          UPDATE_ARGS+=(--allowed-o-auth-scopes)
          for scope in $EXISTING_OAUTH_SCOPES; do
            UPDATE_ARGS+=("$scope")
          done
          
          UPDATE_ARGS+=(--supported-identity-providers)
          for provider in $EXISTING_IDENTITY_PROVIDERS; do
            UPDATE_ARGS+=("$provider")
          done
          
          # Add OAuth flows flag only if enabled
          if [ "$EXISTING_OAUTH_FLOWS_ENABLED" = "true" ]; then
            UPDATE_ARGS+=(--allowed-o-auth-flows-user-pool-client)
          fi
          
          UPDATE_ARGS+=(--output json)
          
          echo "Executing AWS CLI command with OAuth settings preserved..."
          UPDATE_RESULT=$(aws cognito-idp update-user-pool-client "${UPDATE_ARGS[@]}" 2>&1)
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Cognito callback URLs updated successfully"
            
            # Verify the update by checking ALL settings (callback URLs + OAuth settings)
            VERIFIED_CONFIG=$(aws cognito-idp describe-user-pool-client \
              --user-pool-id "$COGNITO_USER_POOL_ID" \
              --client-id "$COGNITO_CLIENT_ID" \
              --output json 2>/dev/null || echo "{}")
            
            VERIFIED_CALLBACKS=$(echo "$VERIFIED_CONFIG" | jq -r '.UserPoolClient.CallbackURLs // []' 2>/dev/null || echo "[]")
            VERIFIED_LOGOUTS=$(echo "$VERIFIED_CONFIG" | jq -r '.UserPoolClient.LogoutURLs // []' 2>/dev/null || echo "[]")
            VERIFIED_OAUTH_FLOWS=$(echo "$VERIFIED_CONFIG" | jq -c '.UserPoolClient.AllowedOAuthFlows // []' 2>/dev/null || echo "[]")
            VERIFIED_OAUTH_SCOPES=$(echo "$VERIFIED_CONFIG" | jq -c '.UserPoolClient.AllowedOAuthScopes // []' 2>/dev/null || echo "[]")
            
            echo "Verified callback URLs: $VERIFIED_CALLBACKS"
            echo "Verified logout URLs: $VERIFIED_LOGOUTS"
            echo "Verified OAuth flows: $VERIFIED_OAUTH_FLOWS"
            echo "Verified OAuth scopes: $VERIFIED_OAUTH_SCOPES"
            
            # Check if our URLs are in the verified list
            if echo "$VERIFIED_CALLBACKS" | grep -q "$CALLBACK_URL"; then
              echo "‚úÖ CloudFront callback URL confirmed in Cognito"
            else
              echo "‚ö†Ô∏è Warning: CloudFront callback URL may not be in Cognito"
            fi
            
            # Verify OAuth settings are preserved
            if [ "$VERIFIED_OAUTH_FLOWS" != "[]" ] && [ "$VERIFIED_OAUTH_SCOPES" != "[]" ]; then
              echo "‚úÖ OAuth flows and scopes preserved successfully"
            else
              echo "‚ö†Ô∏è Warning: OAuth flows or scopes may have been cleared"
              echo "Please verify in AWS Console and run 'terraform apply' to restore if needed"
            fi
          else
            echo "‚ùå Failed to update Cognito callback URLs"
            echo "Error output: $UPDATE_RESULT"
            echo ""
            echo "Please manually update in AWS Console:"
            echo "  Cognito User Pool: $COGNITO_USER_POOL_ID"
            echo "  Client ID: $COGNITO_CLIENT_ID"
            echo "  Add Callback URL: $CALLBACK_URL"
            echo "  Add Logout URL: $LOGOUT_URL"
            exit 1
          fi
      
      - name: Get frontend URL
        env:
          DIST_ID: ${{ env.DIST_ID }}
        run: |
          if [ -z "$DIST_ID" ]; then
            echo "‚ö†Ô∏è CloudFront distribution ID not available"
            exit 0
          fi
          
          # Get CloudFront distribution domain name
          FRONTEND_DOMAIN=$(aws cloudfront get-distribution \
            --id $DIST_ID \
            --query 'Distribution.DomainName' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$FRONTEND_DOMAIN" ]; then
            FRONTEND_URL="https://${FRONTEND_DOMAIN}"
            echo "üöÄ Deployment completed successfully!"
            echo "üìç Frontend URL: $FRONTEND_URL"
            echo ""
            echo "Test the deployment:"
            echo "curl -I $FRONTEND_URL"
          else
            echo "üöÄ Deployment completed successfully!"
            echo "‚ö†Ô∏è Could not retrieve CloudFront domain name"
          fi

